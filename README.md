# Cloud Run workshop

## Introduction

In this workshop, we'll demystify Cloud Run, a powerful service that lets you run stateless containers that are automatically scaled up or down based on demand. You'll gain practical experience through hands-on labs and exercises. It covers the following topics:

- Deploying applications from source code or container images
- Managing traffic, including A/B testing and blue/green deployments
- Configuring custom domains and SSL certificates
- Integrating with other Google Cloud services Get ready to unlock the potential of serverless with Cloud Run!

## Get the project

```bash
git clone -b labs/cloud-run https://github.com/rgalite/gke-review-apps-delivery-workshop
```

## Prepare your environment

To ease commands writing, you will need to define some environment variables.

```bash
export REGION=europe-west9
export REPOSITORY_NAME=app
export PROJECT_ID=$(gcloud config get project)
```

## Build the app container images

- Create a repository named `$REPOSITORY_NAME` to store your container images in the region `$REGION`.

  ```bash
  gcloud artifacts repositories create $REPOSITORY_NAME --repository-format=docker --location=$REGION
  ```

- You will be building the container images off of Cloud Build. Run the command to activate the service:

  ```bash
  gcloud services enable cloudbuild.googleapis.com
  ```

- Make sure the default service account is the [preferred service account](https://cloud.google.com/build/docs/securing-builds/configure-user-specified-service-accounts) Cloud Build is using to build the artifacts.

- Run the skaffold command to build and store the images for both services in the given repository.

  ```bash
  skaffold build --default-repo=$REGION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY_NAME -p prod,cb
  ```

- Verify all images have been created and stored successfully. Run the following command to show the produced container images:

  ```bash
  gcloud artifacts docker images list $REGION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY_NAME --include-tags
  ```

- Search for your tag and store the container images with their tags in environment variables:

  ```bash
  export FRONTEND_CONTAINER_IMAGE=europe-west9-docker.pkg.dev/$PROJECT_ID/$REPOSITORY_NAME/frontend:513aefb
  export CMS_CONTAINER_IMAGE=europe-west9-docker.pkg.dev/$PROJECT_ID/$REPOSITORY_NAME/cms:513aefb
  ```

## Deploy the frontend service to Cloud Run

Run the following command to deploy the frontend service. Reply yes to any invitation to active APIs.

```bash
gcloud run deploy frontend \
  --image=$FRONTEND_CONTAINER_IMAGE \
  --region=$REGION \
  --set-env-vars=STRAPI_API_URL=https://example.com \
  --allow-unauthenticated
```

## Deploy the backend service to Cloud Run

### Create the Cloud SQL instance

- Prepare some environment variables.

  ```bash
  export INSTANCE_NAME=cms
  export PG_ROOT_PASSWORD=$(openssl rand -hex 32)
  ```

- Create a Cloud SQL instance with Postgresql 14, named `$INSTANCE_NAME` with a tier `db-g1-small` in the region `$REGION`.
  Set the root password to `$PG_ROOT_PASSWORD`.

  ```bash
  gcloud sql instances create $INSTANCE_NAME \
    --database-version=POSTGRES_14 \
    --region $REGION \
    --tier db-g1-small \
    --root-password $PG_ROOT_PASSWORD
    --async
  ```

- Store the Cloud SQL instance connection name in a environment variable.

  ```bash
  export CMS_INSTANCE_CONNECTION_NAME=$(gcloud sql instances describe cms --format="get(connectionName)")
  ```

- Create a database named `cms`.

  ```bash
  gcloud sql databases create cms --instance=$INSTANCE_NAME
  ```

### Secrets

Create the secrets for the application. Their value are randomly generated by the openssl command.

```bash
gcloud secrets create cms_app_keys

echo "$(openssl rand -hex 32),$(openssl rand -hex 32)" | gcloud secrets versions add cms_app_keys \
  --data-file=-
```

```bash
gcloud secrets create cms_api_token_salt

echo "$(openssl rand -hex 32)" | gcloud secrets versions add cms_api_token_salt \
  --data-file=-
```

```bash
gcloud secrets create cms_admin_jwt_secret

echo "$(openssl rand -hex 32)" | gcloud secrets versions add cms_admin_jwt_secret \
  --data-file=-
```

```bash
gcloud secrets create cms_transfer_token_salt

echo "$(openssl rand -hex 32)" | gcloud secrets versions add cms_transfer_token_salt \
  --data-file=-
```

```bash
gcloud secrets create cms_jwt_secret

echo "$(openssl rand -hex 32)" | gcloud secrets versions add cms_jwt_secret \
  --data-file=-
```

```bash
gcloud secrets create cms_database_url

echo "socket://postgres:$PG_ROOT_PASSWORD@/cloudsql/$CMS_INSTANCE_CONNECTION_NAME?db=cms" | gcloud secrets versions add cms_database_url \
  --data-file=-
```

### Set permissions

Our cms service will need to connect to a Cloud SQL instance and consume secrets from Secret Manager.

- Prepare some environment variable

  ```bash
  export CMS_SERVICE_ACCOUNT=cms-sa
  export CMS_SERVICE_ACCOUNT_EMAIL=$CMS_SERVICE_ACCOUNT@$PROJECT_ID.iam.gserviceaccount.com
  ```

- Create a service account for the service.

  ```bash
  gcloud iam service-accounts create $CMS_SERVICE_ACCOUNT
  ```

- Give the service account permissions to connect to the Cloud SQL Instance

  ```bash
  gcloud projects add-iam-policy-binding $PROJECT_ID \
  --member="serviceAccount:$CMS_SERVICE_ACCOUNT_EMAIL" \
  --role="roles/cloudsql.client"
  ```

Our cms service will need to consume secrets from Secret Manager.

```bash
for secret in cms_app_keys cms_api_token_salt cms_admin_jwt_secret cms_transfer_token_salt cms_jwt_secret cms_database_url; do gcloud secrets add-iam-policy-binding $secret \
--member="serviceAccount:$CMS_SERVICE_ACCOUNT_EMAIL" \
--role="roles/secretmanager.secretAccessor"; done
```

### Deploy the cms application

```bash
gcloud run deploy cms \
  --image=$CMS_CONTAINER_IMAGE \
  --region=$REGION \
  --set-env-vars="DATABASE_CLIENT=postgres" \
  --service-account=$CMS_SERVICE_ACCOUNT_EMAIL \
  --set-cloudsql-instances=$CMS_INSTANCE_CONNECTION_NAME \
  --set-secrets="API_TOKEN_SALT=cms_api_token_salt:latest,APP_KEYS=cms_app_keys:latest,ADMIN_JWT_SECRET=cms_admin_jwt_secret:latest,TRANSFER_TOKEN_SALT=cms_transfer_token_salt:latest,JWT_SECRET=cms_jwt_secret:latest,DATABASE_URL=cms_database_url:latest" \
  --allow-unauthenticated
```

Store the URL in a environment variable:

```bash
export BACKEND_URL=$(gcloud run services describe cms --format="get(status.url)" --region $REGION)
```

Visit your URL and make sure the `/api/restaurants` path returns something.

## Update the frontend application service

```bash
gcloud run services update frontend --update-env-vars="STRAPI_API_URL=$BACKEND_URL/api" --region $REGION
```

You should see the restaurants being loaded.

## Expose everything behind a load balancer
